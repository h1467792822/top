
#include <top/core/prefix_tree.h>
#include <stdlib.h> //for malloc/free
#include <string.h> //for memset
#include <stdio.h>

#define PREFIX_TREE_NODE( n ) ((struct top_prefix_tree_node*)(n & ~3))
#define PREFIX_TREE_HAS_KEY( n ) ( n & 1 )

#define PREFIX_TREE_SLOT_SIZE 64 
#define PREFIX_TREE_KEY_SIZE (4 * sizeof(void*))


typedef unsigned int top_prefix_tree_slot_map[256];
typedef const unsigned int top_prefix_tree_slot_map_const[256];
typedef char top_prefix_tree_key_map[65];
typedef const char top_prefix_tree_key_map_const[65];

void top_prefix_slot_map_init(to_prefix_tree_slot_map slot_map, top_prefix_tree_key_map_const key_map)
{
	int i;
	for(i = 0; i < 256; ++i)
		slot_map[i] = 255;
	for(i = 0; i < 64; ++i)
		slot_map[key_map[i]] = i;
}

struct top_prefix_tree_key {
	union {
	char key[PREFIX_TREE_KEY_SIZE];
	struct {
		void* data;
		char short_key[PREFIX_TREE_KEY_SIZE - sizeof(void*)];
	};
	};
	unsigned long next;
};

struct top_prefix_tree_slots {
	unsigned long slots[PREFIX_TREE_SLOT_SIZE];
	void* data;
};

enum top_prefix_match_result {
	MATCHED = 0,
	MATCH_NEXT , /** 本节点匹配成功，还需要继续匹配下个节点 */
	MATCH_PARTIAL, /** 本节点部分匹配成功，如果是插入操作，需要分裂当前节点 */
	UNMATCHED, /** 第一个字节就不匹配，如果是插入操作，需要生成新的节点 */
};

struct top_prefix_match_ctx {
	unsigned long* pparent; /** 父节点，父节点的低位会记录当前节点的状态，是否有data，是否有压缩的key */
	struct top_prefix_tree_node_key* current; /** 当前节点，因为内部是链表结构，这可能不是首节点 */
	unsigned int matched_from; /** 本节点开始匹配的位置 */
	unsigned int matched_size; /** 当前key中成功匹配的数量 */
	const char* next_key; /** 匹配后key的位置 */
	unsigned long* pnext; /** 本节点匹配完全成功后需要继续匹配的下一个节点的地址，它成为下一次匹配的pparent的值 */
};

static inline void* top_prefix_tree_ctx_find(struct top_prefix_match_ctx* ctx)
{
	int has_compress_key;
	struct top_prefix_tree_key* tree_key;
	struct top_prefix_tree_slots* tree_slots;
	do {
	has_compress_key = PREFIX_TREE_HAS_KEY(*ctx->pparent);
	if(has_compress_key) {
		tree_key = PREFIX_TREE_KEY(*ctx->pparent);
		if(tree_key == 0 || *ctx->key == 0) return 0;
		rlt = top_prefix_tree_key_match(ctx);
		switch(rlt) {
			case MATCHED:
			return top_prefix_tree_ctx_get_data(ctx);
			case MATCH_NEXT:
		   break;	
			case MATCH_PREFIX:
			case UNMATCHED:
			default:
		   return 0;
		}
	}else{
		tree_slots = PREFIX_TREE_SLOTS(*ctx->pparent);
		if(tree_slots == 0) return 0;
		if(*ctx->key == 0) return tree_slots->data;
		ctx->pparent = top_prefix_tree_get_slot(tree,slots,*ctx->key);
		++ctx->key;
	}
	}while(1);
}

static inline unsigned long* top_prefix_tree_get_slot(struct top_prefix_tree* tree,struct top_prefix_tree_slots* slots,char c)
{
	int slot_idx = tree->slot_map[c];
	assert(slot_idx < 64);
	return &slots->slots[slot_idx];
}

static inline enum top_prefix_match_result top_prefix_tree_key_match(struct top_prefix_tree_key* tree_key,struct top_prefix_match_ctx* ctx)
{
    unsigned int i;
	unsigned int size;
    do {
		size  = PREFIX_TREE_KEY_SIZE(tree_key);
        for(i = 0; i < size; ++i) {
			if(tree_key->key[i] == PREFIX_TREE_SKIP_KEY) continue;
            if(tree_key->key[i] == 0) {
                if(ctx->key[i] == 0) {
					ctx->current = tree_key;
					ctx->matched_siz = i;
					ctx->key += i;
                    return MATCHED;
                } else {
					struct top_prefix_tree_slots* slots = PREFIX_TREE_SLOTS(tree_key);
					ctx->pparent = top_prefix_tree_get_slot(tree,slots,key[i]);
					ctx->key += i + 1;
					return MATCH_NEXT;
                }
            } else if(ctx->key[i] == 0) {
                ctx->current = tree_key;
				ctx->matchd_size = i;
				ctx->key += i;
				return MATCH_PREFIX;
            } else if(node->key[i] != *key) {
                ctx->current = tree_key;
				ctx->matched_size = i;
				ctx->key += i;
				return UNMATCHED;
			}
        }
        tree_key = PREFIX_TREE_KEY(tree_key->next);
		ctx->key += size;
    } while(tree_key);
}



void * top_prefix_tree_simple_find(struct top_prefix_tree* tree, const char* key)
{
	if(tree->root == 0) return 0;
	struct top_prefix_tree_match_ctx ctx;
	memset(&ctx,0,sizeof(ctx));
	ctx->pparent = &tree->root;
	if(key == 0) 
		ctx->key = "";
	else
		ctx->key = key;
	return top_prefix_tree_ctx_find(&ctx);
}

